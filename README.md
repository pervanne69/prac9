# Практическая работа № 9  

**Дисциплина:** Вычислительные системы реального времени  
**Автор:** Pogosian Samvel  
**ID пользователя:** 23К0180  
**Дата:** 02/11/2025  

---

## Состав проекта

- `sensor.c` — процесс сенсора, собирающий системные данные (через `vm_stat`) и отправляющий их в очередь сообщений.  
- `monitor.c` — процесс мониторинга, получающий сообщения от `sensor.c` и отображающий их на экране до получения сигнала `"end"`.  
- `writer.c` — процесс записи текущей даты и времени в сегмент разделяемой памяти для последующего чтения.  
- `reader.c` — процесс чтения данных из разделяемой памяти и завершения работы при получении `"end"`.  
- `sharmem.c` — демонстрация обмена данными между процессами через POSIX shared memory с использованием `fork()` и `mmap()`.  
- `shm_write.c` — запись блоков данных в сегмент System V shared memory с контролем количества байт и индикаторов завершения.  
- `shmem_read.c` — чтение блоков данных из сегмента System V shared memory до окончания записи (`complete=1`).  
- `msgq_send.c` — пример отправки сообщений в очередь сообщений и завершения передачи при `"end"`.  
- `msgq_recv.c` — пример получения сообщений из существующей очереди сообщений с использованием `ftok` и `msgget`.  
- `msgq.txt` — вспомогательный файл для генерации ключа очереди сообщений.  
- `README.md` — описание проекта.  

---

## Назначение проекта

Практическая работа демонстрирует:

1. Использование очередей сообщений (`msgget`, `msgsnd`, `msgrcv`) для обмена данными между процессами.  
2. Работа с разделяемой памятью System V и POSIX (`shmget`, `shmat`, `shmdt`, `shmctl`, `mmap`, `shm_open`).  
3. Синхронизация процессов через флаги (`updated`, `complete`) и контроль завершения работы (`"end"`).  
4. Формирование и обработка системных данных (текущее состояние памяти, дата и время).  
5. Безопасное чтение, запись и очистка IPC-ресурсов после завершения работы процессов.  
6. Использование стандартных функций C для работы с памятью, строками и системными вызовами (`popen`, `fgets`, `sleep`).  
7. Демонстрация взаимодействия нескольких процессов через fork, shared memory и очереди сообщений.  

---

## Компиляция и запуск

Для сборки всех программ используйте GCC и Make:

```bash
make
```

## Для обмена через очередь сообщений:
```
   ./sensor       # Отправка системной информации
   ./monitor      # Получение и отображение информации
``` 
## Для работы с разделяемой памятью (дата/время):
```
   ./writer       # Запись текущей даты/времени в память
   ./reader       # Чтение данных из памяти
```
## Для демонстрации POSIX shared memory с fork:
```
   ./sharmem
```
## Для работы с пользовательскими очередями сообщений:
```
   ./msgq_send
   ./msgq_recv
```
## Для обмена блоками данных через System V shared memory:
```
   ./shm_write
   ./shmem_read
```
## Очистка

После работы всех программ IPC-ресурсы очищаются автоматически (msgctl, shmctl, shm_unlink).
Для ручной очистки, если необходимо, используйте команды:
```
   ipcs -q          # список очередей сообщений
   ipcrm -q <id>    # удаление очереди сообщений
   ipcs -m          # список сегментов памяти
   ipcrm -m <id>    # удаление сегмента памяти
```
